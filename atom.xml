<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>My Curious</title>
  <subtitle>suwey&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.suwey.net/"/>
  <updated>2017-03-30T18:31:09.000Z</updated>
  <id>http://www.suwey.net/</id>
  
  <author>
    <name>suwey</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mermaid图表介绍</title>
    <link href="http://www.suwey.net/2017/03/30/mermaid-diagrams/"/>
    <id>http://www.suwey.net/2017/03/30/mermaid-diagrams/</id>
    <published>2017-03-29T17:22:52.000Z</published>
    <updated>2017-03-30T18:31:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近被人推荐使用了一个叫<code>Typora</code>的Markdown编辑器，这个编辑器最大的特点就是真正的所见即所得，连preview都省了，界面简洁功能强大，把玩的时候发现此编辑器不仅支持之前提到的<code>js-sequence</code>和<code>flowchart</code>而且还支持更多种类的图表而这些图表都来自一个叫<code>mermaid</code>的项目，果断移植过来加以学习。</p>
<a id="more"></a>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><div class="mermaid">graph LR;  
　　A--&gt;B;    
　　A--&gt;C;  
　　B--&gt;D;  
　　C--&gt;D;</div>
<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><div class="mermaid">sequenceDiagram
　　　participant Alice
　　　participant Bob
　　　Alice-&gt;John:Hello John, how are you?
　　　loop Healthcheck
　　　　　John-&gt;John:Fight against hypochondria
　　　end
　　　Note right of John:Rational thoughts &lt;br/&gt;prevail...
　　　John--&gt;Alice:Great!
　　　John-&gt;Bob: How about you?
　　　Bob--&gt;John: Jolly good!</div>
<h2 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h2><div class="mermaid">gantt
　　　dateFormat　YYYY-MM-DD
　　　title Adding GANTT diagram functionality to mermaid
　　　section A section
　　　Completed task　　:done, des1, 2014-01-06,2014-01-08
　　　Active task 　　　　:active, des2, 2014-01-09, 3d
　　　future task 　　　　:　　　  des3, after des2, 5d
　　　future task2　　　　:　　　  des4, after des3, 5d
　　　section Critical tasks
　　　Completed task in the critical line　:crit, done, 2014-01-06,24h
　　　Implement parser and json　　　　　　:crit, done, after des1, 2d
　　　Create tests for parser　　　　　　　:crit, active, 3d
　　　Future task in critical line　　　　　:crit, 5d
　　　Create tests for renderer　　　　　　:2d
　　　Add to ,mermaid　　　　　　　　　　　:1d</div>
<h2 id="形状和颜色变化"><a href="#形状和颜色变化" class="headerlink" title="形状和颜色变化"></a>形状和颜色变化</h2><div class="mermaid">graph TB
    sq[Square shape] --&gt; ci((Circle shape))
        subgraph A subgraph
            di&#123;Diamond with  line break&#125; -.-&gt; ro(Rounded)
            di==&gt;ro2(Rounded square shape)
        end
        e --&gt; od3&gt;Really long text with linebreak&lt;br&gt;in an Odd shape]
        cyr[Cyrillic]--&gt;cyr2((Circle shape Начало));
        classDef green fill:#9f6,stroke:#333,stroke-width:2px;
        classDef orange fill:#f96,stroke:#333,stroke-width:4px;
        class sq,e green
        class di orange</div>
<p>这样一看这个系列简直太强大了，而且语法和开头提到的两个项目差不多，另外测试的时候发现<code>mermaid</code>的js代码可能会和<code>js-sequence</code>有点冲突所以最好不要一个页面同时使用两种图表，其实可能这些项目都还有很多功能没有发掘出来，估计现有的功能对于博客来说就已经很够用了。以上图表示例源文件来自<a href="http://blog.csdn.net/wangyaninglm/article/details/52887045" target="_blank" rel="external">这里</a>，至于怎么用到<code>hexo</code>中就不用在赘述了吧，照着之前整合<code>js-sequence</code>的方式做也行，学下现在已经有了的<code>hexo-filter-sequence</code>插件来做更好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近被人推荐使用了一个叫&lt;code&gt;Typora&lt;/code&gt;的Markdown编辑器，这个编辑器最大的特点就是真正的所见即所得，连preview都省了，界面简洁功能强大，把玩的时候发现此编辑器不仅支持之前提到的&lt;code&gt;js-sequence&lt;/code&gt;和&lt;code&gt;flowchart&lt;/code&gt;而且还支持更多种类的图表而这些图表都来自一个叫&lt;code&gt;mermaid&lt;/code&gt;的项目，果断移植过来加以学习。&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://www.suwey.net/categories/hexo/"/>
    
    
      <category term="mermaid" scheme="http://www.suwey.net/tags/mermaid/"/>
    
  </entry>
  
  <entry>
    <title>GDB调试初探</title>
    <link href="http://www.suwey.net/2017/03/15/gdb-debug-learn/"/>
    <id>http://www.suwey.net/2017/03/15/gdb-debug-learn/</id>
    <published>2017-03-15T04:00:00.000Z</published>
    <updated>2017-03-30T17:24:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>久闻GDB大名，在 <strong>The Exploit Laboratory</strong> 一书中看到第一章就是介绍这个的，迅速跟进。</p>
<p>先上一段测试代码crash1.c:</p>
<figure class="highlight c"><figcaption><span>crash1.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> number;</span><br><span class="line">       <span class="keyword">int</span> *pointer;</span><br><span class="line">       number = atoi((*argv)[<span class="number">1</span>]);</span><br><span class="line">       pointer = number;</span><br><span class="line">       printnum(pointer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printnum</span><span class="params">(<span class="keyword">int</span>* x)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"The number supplied is %d\n"</span>, *x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>编译 <em>gcc -o crash1 crash1.c</em> , 执行 <em>gdb crash1</em>，run运行程序发现报段错误，<em>backtrace</em> 查看调用信息，<em>x/10i $eip</em> 查看内存反汇编信息：</p>
<figure class="highlight plain"><figcaption><span>(gdb) x/10i $eip</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">0xb7e55580:	movzbl (%edx),%eax</span><br><span class="line">0xb7e55583:	mov    0x34(%esi),%ecx</span><br><span class="line">0xb7e55586:	movsbl %al,%edx</span><br><span class="line">0xb7e55589:	testb  $0x20,0x1(%ecx,%edx,2)</span><br><span class="line">0xb7e5558e:	je     0xb7e555a1</span><br><span class="line">0xb7e55590:	add    $0x1,%ebp</span><br><span class="line">0xb7e55593:	movzbl 0x0(%ebp),%eax</span><br><span class="line">0xb7e55597:	movsbl %al,%edx</span><br><span class="line">0xb7e5559a:	testb  $0x20,0x1(%ecx,%edx,2)</span><br><span class="line">0xb7e5559f:	jne    0xb7e55590</span><br></pre></td></tr></table></figure>
<p>这样一看基本上傻眼了，gdb默认反汇编为 <em>AT&amp;T</em> 的语法风格，转成 <em>NASM</em> 风格会好懂一点，在用户目录下建立 <em>.gdbinit</em> 文件写入 <em>set disassembly-flavor intel</em> 让当前用户使用gdb时默认显示intel风格的汇编代码:</p>
<figure class="highlight plain"><figcaption><span>(gdb) x/10i $eip</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">   0xb7e55580:	movzx  eax,BYTE PTR [edx]</span><br><span class="line">0xb7e55583:	mov    ecx,DWORD PTR [esi+0x34]</span><br><span class="line">0xb7e55586:	movsx  edx,al</span><br><span class="line">0xb7e55589:	test   BYTE PTR [ecx+edx*2+0x1],0x20</span><br><span class="line">0xb7e5558e:	je     0xb7e555a1</span><br><span class="line">0xb7e55590:	add    ebp,0x1</span><br><span class="line">0xb7e55593:	movzx  eax,BYTE PTR [ebp+0x0]</span><br><span class="line">0xb7e55597:	movsx  edx,al</span><br><span class="line">0xb7e5559a:	test   BYTE PTR [ecx+edx*2+0x1],0x20</span><br><span class="line">0xb7e5559f:	jne    0xb7e55590</span><br></pre></td></tr></table></figure>
<p>现在就习惯了很多，最上面是最后一步的位置，将edx寄存器存放地址上取byte长度存入eax，查看寄存器信息:</p>
<figure class="highlight plain"><figcaption><span>(gdb) info registers</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">      eax            0x0	0</span><br><span class="line">ecx            0xbffff774	-1073744012</span><br><span class="line">edx            0x68	104</span><br><span class="line">ebx            0xb7fc6ff4	-1208193036</span><br><span class="line">esp            0xbffff600	0xbffff600</span><br><span class="line">ebp            0x68	0x68</span><br><span class="line">esi            0xb7fc78c0	-1208190784</span><br><span class="line">edi            0x0	0</span><br><span class="line">eip            0xb7e55580	0xb7e55580</span><br><span class="line">eflags         0x10283	[ CF SF IF RF ]</span><br><span class="line">cs             0x73	115</span><br><span class="line">ss             0x7b	123</span><br><span class="line">ds             0x7b	123</span><br><span class="line">es             0x7b	123</span><br><span class="line">fs             0x0	0</span><br><span class="line">gs             0x33	51</span><br></pre></td></tr></table></figure>
<p>可以看到edx指向的地址是0x68，是一个不可执行地址，故触发异常。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;久闻GDB大名，在 &lt;strong&gt;The Exploit Laboratory&lt;/strong&gt; 一书中看到第一章就是介绍这个的，迅速跟进。&lt;/p&gt;
&lt;p&gt;先上一段测试代码crash1.c:&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;figcaption&gt;&lt;span&gt;crash1.c&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;** argv)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; number;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *pointer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       number = atoi((*argv)[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       pointer = number;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       printnum(pointer);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;printnum&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;* x)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;The number supplied is %d\n&quot;&lt;/span&gt;, *x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://www.suwey.net/categories/Linux/"/>
    
    
      <category term="gdb" scheme="http://www.suwey.net/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>Hello World Hexo3</title>
    <link href="http://www.suwey.net/2017/03/15/hello-world-hexo3/"/>
    <id>http://www.suwey.net/2017/03/15/hello-world-hexo3/</id>
    <published>2017-03-15T04:00:00.000Z</published>
    <updated>2017-03-30T17:25:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>. Deployment settings has been changed and Chinese friends may need VPN to complete <code>hexo init</code> or <code>npm install</code> or even <code>hexo deploy</code>, watch out that <code>hexo-deployer-git</code> and <code>hexo-generator-feed</code> need to install separately and <code>hexo-generator-sitemap</code> may cause error when run <code>hexo g</code>.    </p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
<h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><p>My way is <code>npm update -g hexo-cli</code>, <code>hexo init newblog</code>, <code>cp newblog/package.json oldblog/</code>, watch out if you have changed <code>oldblog/package.json</code>, try <code>vimdiff oldblog/package.json newblog/package.json</code> first, and the last hit <code>cd oldblog; rm -rf node_modules; npm install</code>. </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;http://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;http://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;http://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;. Deployment settings has been changed and Chinese friends may need VPN to complete &lt;code&gt;hexo init&lt;/code&gt; or &lt;code&gt;npm install&lt;/code&gt; or even &lt;code&gt;hexo deploy&lt;/code&gt;, watch out that &lt;code&gt;hexo-deployer-git&lt;/code&gt; and &lt;code&gt;hexo-generator-feed&lt;/code&gt; need to install separately and &lt;code&gt;hexo-generator-sitemap&lt;/code&gt; may cause error when run &lt;code&gt;hexo g&lt;/code&gt;.    &lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://www.suwey.net/categories/hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>docker入门实战笔记</title>
    <link href="http://www.suwey.net/2017/03/15/docker-rudiments-and-practice-part1/"/>
    <id>http://www.suwey.net/2017/03/15/docker-rudiments-and-practice-part1/</id>
    <published>2017-03-15T04:00:00.000Z</published>
    <updated>2017-03-30T17:23:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要是<a href="http://yuedu.baidu.com/ebook/d817967416fc700abb68fca1?fr=aladdin&amp;key=docker%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98" target="_blank" rel="external">Docker入门实战</a>这本电子书的学习记录，对其中一些原理相关代码的记录和实践就不再赘述一些更为基本的概念，这本书是由<a href="http://www.dockone.io" target="_blank" rel="external">DockerOne</a>编译的，其条理和内容都很不错非常值得一读。继续阅读之前需要先了解下容器是什么、和VM的区别是什么、Docker解决了什么问题以及镜像、数据卷、LXC、Cgroups、Union文件系统等基本概念，然后安装好docker和gcc就可以愉快的进入下文了，如果对Docker的源码有兴趣可以看看这个系列的文章<a href="http://www.infoq.com/cn/search.action?queryString=Docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90&amp;page=1&amp;searchOrder=&amp;sst=uZnwt8z7LUYMOcuH" target="_blank" rel="external">列表</a>。</p>
<a id="more"></a>
<h2 id="LXC-核心：Linux-Namespaces"><a href="#LXC-核心：Linux-Namespaces" class="headerlink" title="LXC 核心：Linux Namespaces"></a>LXC 核心：Linux Namespaces</h2><p>Docker是利用LXC实现类似VM的功能的（之后换成了libcontainer，具体区别和对libcontainer的分析请看<a href="http://www.infoq.com/cn/articles/docker-container-management-libcontainer-depth-analysis" target="_blank" rel="external">这里</a>），而LXC依赖Linux内核的3种隔离机制：</p>
<ol>
<li>Chroot</li>
<li>Cgroups</li>
<li>Namespaces</li>
</ol>
<p>本文主要关注Namespaces，在3.12 kernel中Linux支持以下6种Namespace：</p>
<ol>
<li>UTS: hostname</li>
<li>IPC: 进程间通信</li>
<li>PID: Chroot 进程树</li>
<li>NS: 挂载点</li>
<li>NET: 网络访问，包括接口</li>
<li>USER: user-id映射</li>
</ol>
<h2 id="UTS-Namespace"><a href="#UTS-Namespace" class="headerlink" title="UTS Namespace"></a>UTS Namespace</h2><p>关于上述内容在<a href="http://www.infoq.com/cn/articles/docker-core-technology-preview" target="_blank" rel="external">这里</a>有更详细的解释，下面试着在容器中启动<code>/bin/bash</code>，编写代码<a href="/attachments/docker/practice/main-0-template.c">main-0-template.c</a>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Last Update:2016-02-25 09:15:39</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * @file main-0-template.c</span><br><span class="line"> * @brief docker lxc test</span><br><span class="line"> * @author suwey_1990@126.com</span><br><span class="line"> * @version 0.0.1</span><br><span class="line"> * @date 2016-02-25</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_SIZE (1024 * 1024)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> child_stack[STACK_SIZE];</span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> child_args[] = &#123;</span><br><span class="line">    <span class="string">"/bin/bash"</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">child_main</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" - World !\n"</span>);</span><br><span class="line">    execv(child_args[<span class="number">0</span>], child_args);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Ooops\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" - Hello ?\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> child_pid = clone(child_main, child_stack + STACK_SIZE, SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">    waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译执行<code>gcc -Wall main-0-template.c -o ns &amp;&amp; sudo ./ns</code>可以看到输出，从结果看就是很普通的helloworld只不过是在子进程中输出的，然后试着修改下主机名，修改代码为<a href="/attachments/docker/practice/main-1-uts.c">main-1-uts.c</a>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//require root</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">child_main</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" - World !\n"</span>);</span><br><span class="line">    sethostname(<span class="string">"In Namespace"</span>, <span class="number">12</span>);</span><br><span class="line">    execv(child_args[<span class="number">0</span>], child_args);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Ooops\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" - Hello ?\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> child_pid = clone(child_main, child_stack + STACK_SIZE, CLONE_NEWUTS | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">    waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要不同是使用了<code>CLONE_NEWUTS</code>标记，运行后会发现hostname已经被修改了如果没有调用<code>exit</code>命令则会一直处在容器中，可以看到使用Namespace技术非常简单，只需要调用<code>clone</code>函数并设置好标记，下面继续学习下IPC是如何隔离的。</p>
<h2 id="IPC-Namespace"><a href="#IPC-Namespace" class="headerlink" title="IPC Namespace"></a>IPC Namespace</h2><p>很自然的可以想到肯定有一个别的标记对应此类Namespace，这个标记就是<code>CLONE_NEWIPC</code>，但是这次有点不同的是这里有父子进程通信的问题需要解决，clone和它的parent会分享内存空间，因此有以下几种方式可以使用：</p>
<ul>
<li>信号</li>
<li>poll内存</li>
<li>套接字</li>
<li>文件和文件描述符</li>
</ul>
<p>这几种里面首先信号可以直接排除，因为在容器内的进程上下文已经和父进程不一样了，至于poll内存的方式因为效率问题暂不考虑，socket套接字这种方法和文件的方式都可以但是这里提供一种由<code>Lennart Poettering</code>在<code>Systemd&#39;s &quot;nspawn&quot;</code>中使用过的技术，通过监视一对<code>pipe</code>上的事件来完成通信。首先需要初始化一对pipe：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> checkpoint[<span class="number">2</span>];</span><br><span class="line">pipe(checkpoint);</span><br></pre></td></tr></table></figure>
<p>这里的思想是在parent中触发一个<code>close</code>事件，并且在child的读取端等待<code>EOF</code>被接收，接收后所有写fd的文件必须被关闭，所以在child等待前就要关闭fd的副本：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(checkpoint[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<p>基于上文模板需要修改部分代码<a href="/attachments/docker/practice/main-2-ipc.c">main-2-ipc.c</a>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">child_main</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    close(checkpoint[<span class="number">1</span>]);</span><br><span class="line">    read(checkpoint[<span class="number">0</span>], &amp;c, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" - World !\n"</span>);</span><br><span class="line">    sethostname(<span class="string">"In Namespace"</span>, <span class="number">12</span>);</span><br><span class="line">    execv(child_args[<span class="number">0</span>], child_args);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Ooops\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pipe(checkpoint);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" - Hello ?\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> child_pid = clone(child_main, child_stack + STACK_SIZE, CLONE_NEWIPC | CLONE_NEWUTS | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">4</span>);</span><br><span class="line">    close(checkpoint[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行此程序可以观察到在父进程完成sleep后容器中的子进程才获得消息然后输出内容，这里还保留着UTS的标志只是为了顺便说明Namespace是可以组合使用的，本质上也是通过各种组合实现不同程度的隔离。</p>
<h2 id="PID-Namespace"><a href="#PID-Namespace" class="headerlink" title="PID Namespace"></a>PID Namespace</h2><p>很自然的可以猜到这次的标记是<code>CLONE_NEWPID</code>，激活此Namespace后将会重置PID计数，子进程<code>getpid()</code>的返回结果将会是1，使用<a href="/attachments/docker/practice/main-3-pid.c">main-3-pid.c</a>进行测试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">child_main</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    close(checkpoint[<span class="number">1</span>]);</span><br><span class="line">    read(checkpoint[<span class="number">0</span>], &amp;c, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" - [%5d] World !\n"</span>, getpid());</span><br><span class="line">    sethostname(<span class="string">"In Namespace"</span>, <span class="number">12</span>);</span><br><span class="line">    execv(child_args[<span class="number">0</span>], child_args);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Ooops\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pipe(checkpoint);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" - [%5d] Hello ?\n"</span>, getpid());</span><br><span class="line">    <span class="keyword">int</span> child_pid = clone(child_main, child_stack + STACK_SIZE, CLONE_NEWPID | CLONE_NEWIPC | CLONE_NEWUTS | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">    close(checkpoint[<span class="number">1</span>]);</span><br><span class="line">    waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后会发现子进程的pid为1，在子进程中即使Kill父进程的pid也只会提示<code>bash: kill: (1674) - No such process</code>，这一点和<code>chroot</code>很像有趣的是此时如果在父进程中使用<code>top</code>将可以看到子进程和它未映射的pid，但是如果在子进程中运行则会发现和父进程是一样的内容，这是因为这类工具往往直接从<code>/proc</code>中获取信息，后面将会讨论如何让子进程也看起来比较正常。</p>
<h2 id="NS-Namespace"><a href="#NS-Namespace" class="headerlink" title="NS Namespace"></a>NS Namespace</h2><p>直接开始吧，使用<a href="/attachments/docker/practice/main-4-ns.c">main-4-ns.c</a>进行测试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">child_main</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    close(checkpoint[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" - [%5d] World !\n"</span>, getpid());</span><br><span class="line">    sethostname(<span class="string">"In Namespace"</span>, <span class="number">12</span>);</span><br><span class="line">    mount(<span class="string">"proc"</span>, <span class="string">"/proc"</span>, <span class="string">"proc"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    read(checkpoint[<span class="number">0</span>], &amp;c, <span class="number">1</span>);</span><br><span class="line">    execv(child_args[<span class="number">0</span>], child_args);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Ooops\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pipe(checkpoint);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" - [%5d] Hello ?\n"</span>, getpid());</span><br><span class="line">    <span class="keyword">int</span> child_pid = clone(child_main, child_stack + STACK_SIZE, CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWIPC | CLONE_NEWUTS | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">    close(checkpoint[<span class="number">1</span>]);</span><br><span class="line">    waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一次将会解决子进程查看命令在上一节中的问题，如果重新挂载基本的文件系统可以在子进程中只能看到自己的设备、文件等等，有兴趣可以自行尝试。不过这里有个问题是当退出子进程后会发现再也使用不了sudo了，提示<code>sudo: no tty present and no askpass program specified</code>，如果使用ps命令则会有错误<code>Error, do this: mount -t proc proc /proc</code>，但是mount命令又需要用sudo来执行，所以这时候如果想使用和<code>/proc</code>相关的命令只能强制重启机器，如果不是虚拟机的话得亲自去机房关机哦。其实这个错误信息已经告诉了此问题的原因，所以解决办法就是在主进程的函数中再调用一次mount，完整文件已经修改可以放心运行。</p>
<h2 id="NET-Namespace"><a href="#NET-Namespace" class="headerlink" title="NET Namespace"></a>NET Namespace</h2><p>这次先不急着上代码，先走一遍基本原理，先查看下本机网络情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo ip link list</span><br><span class="line">[sudo] password for suwey:</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: eno16777736: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:ee:fe:5d brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>
<p>可以看到本机的lo口是启动的，然后直接使用命令创建Net Namespace看看里面的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo ip netns add demo</span><br><span class="line">sudo ip netns exec demo ip link list</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br></pre></td></tr></table></figure>
<p>可以看到其内部的lo口状态是DOWN，和外层的lo互不干扰与之前IPC有同样的隔离级别，如果要在外面和里面的网络进行通信的话可以创建一个P2P管道，使用内核提供的<code>veth</code>接口可以完成这件事情，如果想其可以监听外部主机的端口可以考虑使用<code>DNAT</code>技术，现在可以使用代码<a href="/attachments/docker/practice/main-5-net.c">main-5-net.c</a>测试了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">child_main</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    close(checkpoint[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" - [%5d] World !\n"</span>, getpid());</span><br><span class="line">    sethostname(<span class="string">"In Namespace"</span>, <span class="number">12</span>);</span><br><span class="line">    mount(<span class="string">"proc"</span>, <span class="string">"/proc"</span>, <span class="string">"proc"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    read(checkpoint[<span class="number">0</span>], &amp;c, <span class="number">1</span>);</span><br><span class="line">    system(<span class="string">"ip link set lo up"</span>);</span><br><span class="line">    system(<span class="string">"ip link set veth1 up"</span>);</span><br><span class="line">    system(<span class="string">"ip addr add 192.168.55.222/24 dev veth1"</span>);</span><br><span class="line">    execv(child_args[<span class="number">0</span>], child_args);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Ooops\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pipe(checkpoint);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" - [%5d] Hello ?\n"</span>, getpid());</span><br><span class="line">    <span class="keyword">int</span> child_pid = clone(child_main, child_stack + STACK_SIZE, CLONE_NEWNET | CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWIPC | CLONE_NEWUTS | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">char</span>* cmd;</span><br><span class="line">    asprintf(&amp;cmd, <span class="string">"ip link set veth1 netns %d"</span>, child_pid);</span><br><span class="line">    system(<span class="string">"ip link add veth0 type veth peer name veth1"</span>);</span><br><span class="line">    system(cmd);</span><br><span class="line">    system(<span class="string">"ip link set veth0 up"</span>);</span><br><span class="line">    system(<span class="string">"ip addr add 192.168.55.1/24 dev veth0"</span>);</span><br><span class="line">    <span class="built_in">free</span>(cmd);</span><br><span class="line">    close(checkpoint[<span class="number">1</span>]);</span><br><span class="line">    waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    mount(<span class="string">"proc"</span>, <span class="string">"/proc"</span>, <span class="string">"proc"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后可以看看这时候内部的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@In Namespace my]# ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: veth1@if4: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether 3e:59:c2:bd:59:ad brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 192.168.55.222/24 scope global veth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::3c59:c2ff:febd:59ad/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">[root@In Namespace my]# ping 192.168.55.1</span><br><span class="line">PING 192.168.55.1 (192.168.55.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.55.1: icmp_seq=1 ttl=64 time=0.080 ms</span><br><span class="line">64 bytes from 192.168.55.1: icmp_seq=2 ttl=64 time=0.074 ms</span><br><span class="line">64 bytes from 192.168.55.1: icmp_seq=3 ttl=64 time=0.120 ms</span><br><span class="line">^C</span><br><span class="line">--- 192.168.55.1 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2000ms</span><br><span class="line">rtt min/avg/max/mdev = 0.074/0.091/0.120/0.021 ms</span><br><span class="line">[root@In Namespace my]# route add default gw 192.168.55.1</span><br><span class="line">[root@In Namespace my]# ping 192.168.45.138</span><br><span class="line">PING 192.168.45.138 (192.168.45.138) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.45.138: icmp_seq=1 ttl=64 time=0.072 ms</span><br><span class="line">64 bytes from 192.168.45.138: icmp_seq=2 ttl=64 time=0.129 ms</span><br><span class="line">64 bytes from 192.168.45.138: icmp_seq=3 ttl=64 time=0.115 ms</span><br><span class="line">64 bytes from 192.168.45.138: icmp_seq=4 ttl=64 time=0.113 ms</span><br></pre></td></tr></table></figure>
<p>可以看到添加了路由后是可以连通外部本机地址的，至此就演示完了对网络隔离的方法了，想进一步了解网络虚拟化的话可以查一下Linux kernel新支持的接口类型：macvlan、vlan、vxlans…。</p>
<h2 id="USER-Namespace"><a href="#USER-Namespace" class="headerlink" title="USER Namespace"></a>USER Namespace</h2><p>这个Namespace在入门实战这个电子书中没有讲，但是像我这种有追求得读者怎么可以让这篇文章最后少了这么一个重要的内容，于是通过牛逼的搜索引擎终于还是补上了，主要是参考了<a href="https://lwn.net/Articles/532593" target="_blank" rel="external">这篇</a>。结合前面的内容显然这次的标记是<code>CLONE_NEWUSER</code>，与前面有一点不同的是如果仅使用此标记是不需要使用root权限的，先运行<a href="/attachments/docker/practice/demo-userns.c">demo-userns.c</a>简单看一下效果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">child_main</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">cap_t</span> caps;</span><br><span class="line">      <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"eUID = %ld, eGID = %ld\n"</span>, (<span class="keyword">long</span>)geteuid(), (<span class="keyword">long</span>)getegid());</span><br><span class="line">          caps = cap_get_proc();</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"capabilities: %s\n"</span>, cap_to_text(caps, <span class="literal">NULL</span>));</span><br><span class="line">          <span class="keyword">if</span>(arg == <span class="literal">NULL</span>)</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          sleep(<span class="number">5</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> child_pid = clone(child_main, child_stack + STACK_SIZE, CLONE_NEWUSER | SIGCHLD, argv[<span class="number">1</span>]);</span><br><span class="line">      waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意编译前需要运行<code>sudo dnf install libcap-devel</code>，编译时需要指定<code>-lcap</code>，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eUID = 65534, eGID = 65534</span><br><span class="line">capabilities: = cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,37+ep</span><br></pre></td></tr></table></figure>
<p>这里最后面显示的是子进程的权限，关于这一块的详情请搜索Linux内核中一种新的权限机制<code>Capabilities</code>（可以看<a href="http://www.cnblogs.com/iamfy/archive/2012/09/20/2694977.html" target="_blank" rel="external">这里</a>了解下），而上面的uid和gid则因为在没有对外部和内部的id进行映射时将分别返回<code>/proc/sys/kernel/overflowuid</code>和<code>/proc/sys/kernel/overflowgid</code>，要注意的一点是这里子进程拥有的权限仅仅针对的是内部对于外部无论调用者拥有何种权限子进程都没有任何权限。那么如何进行映射呢？通过<code>/proc/PID/uid_map</code>和<code>/proc/PID/gid_map</code>即可完成对应的映射，内容格式为<code>ID-inside-ns   ID-outside-ns   length</code>，<code>ID-inside-ns</code>和<code>length</code>一起决定Namespace内部映射到外部的id的范围而<code>ID-outside-ns</code>表示外部id范围的开始的值，但是这个值会如何解释在不同情况所有不同，主要取决于打开<code>/proc/PID/uid_map</code>（或<code>/proc/PID/gid_map</code>）的进程：</p>
<ol>
<li>如果其与目标进程在同一个Namespace中，<code>ID-outside-ns</code>会被解释为父USER Namespace中的uid（或gid）</li>
<li>如果其与目标进程不在同一个Namespace中，<code>ID-outside-ns</code>会被解释为打开<code>/proc/PID/uid_map</code>（或<code>/proc/PID/gid_map</code>）进程所在USER Namespace中的uid（或gid）</li>
</ol>
<p>下面先用命令来理解下这两条规定，执行刚才的程序，随便通过参数传入一个字符串，这时候命令会不停的像刚才一样打印子进程的uid和gid，然后在另一个终端窗口执行<code>ps -C ns -o &#39;pid uid comm&#39;</code>可以看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PID   UID COMMAND</span><br><span class="line">29104  1000 ns        #父id</span><br><span class="line">29105  1000 ns        #子id</span><br></pre></td></tr></table></figure>
<p>然后修改一下map文件<code>echo &#39;0 1000 1&#39; &gt; /proc/29105/uid_map</code>，这时候在原来的终端窗口可以看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eUID = 0, eGID = 65534</span><br><span class="line">capabilities: = cap_chown,cap...</span><br></pre></td></tr></table></figure>
<p>通过修改映射将父进程中为1000的uid关联为0，所以子进程获得的uid之后就也变成了0。关于修改映射文件也是有一定规则的：</p>
<ol>
<li>写入的进程在要映射的PID所在的USER Namespace中必须拥有<code>CAP_SETUID</code>（对于gid来说是<code>CAP_SETGID</code>）权限</li>
<li>不管<code>Capabilities</code>设置如何，写入的进程必须在要在映射PID所在的USER Namespace中或者其父USER Namespace中</li>
<li>至少满足下面的一条<ul>
<li>映射文件中有且仅有一条数据将写入进程在父USER Namespace中的uid（或gid）映射为子USER Namespace的uid（或gid）。这个规则允许子进程自己修改映射。</li>
<li>在父USER Namespace中拥有<code>CAP_SETUID</code>（对于gid来说是<code>CAP_SETGID</code>）权限的进程可以定义任何在父USER Namespace中进程的映射</li>
</ul>
</li>
</ol>
<p>继续完成之前的代码<a href="/attachments/docker/practice/main-6-user.c">main-6-user.c</a>然后测试下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_id_map</span><span class="params">(<span class="keyword">long</span> pid, <span class="keyword">long</span> inside, <span class="keyword">long</span> outside, <span class="keyword">long</span> length, <span class="keyword">char</span>* <span class="built_in">map</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> path[<span class="number">256</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(path, <span class="string">"/proc/%ld/%s"</span>, pid, <span class="built_in">map</span>);</span><br><span class="line">    FILE* file = fopen(path, <span class="string">"w"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(file, <span class="string">"%ld %ld %ld"</span>, inside, outside, length);</span><br><span class="line">    fclose(file);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">child_main</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    close(checkpoint[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" - [%5d] World !\n"</span>, getpid());</span><br><span class="line">    sethostname(<span class="string">"In Namespace"</span>, <span class="number">12</span>);</span><br><span class="line">    mount(<span class="string">"proc"</span>, <span class="string">"/proc"</span>, <span class="string">"proc"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"eUID = %ld, eGID = %ld\n"</span>, (<span class="keyword">long</span>)geteuid(), (<span class="keyword">long</span>)getegid());</span><br><span class="line">    read(checkpoint[<span class="number">0</span>], &amp;c, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"eUID = %ld, eGID = %ld\n"</span>, (<span class="keyword">long</span>)geteuid(), (<span class="keyword">long</span>)getegid());</span><br><span class="line">    system(<span class="string">"ip link set lo up"</span>);</span><br><span class="line">    system(<span class="string">"ip link set veth1 up"</span>);</span><br><span class="line">    system(<span class="string">"ip addr add 192.168.55.222/24 dev veth1"</span>);</span><br><span class="line">    execv(child_args[<span class="number">0</span>], child_args);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Ooops\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pipe(checkpoint);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" - [%5d] Hello ?\n"</span>, getpid());</span><br><span class="line">    <span class="keyword">int</span> child_pid = clone(child_main, child_stack + STACK_SIZE, CLONE_NEWUSER | CLONE_NEWNET | CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWIPC | CLONE_NEWUTS | SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">char</span>* cmd;</span><br><span class="line">    asprintf(&amp;cmd, <span class="string">"ip link set veth1 netns %d"</span>, child_pid);</span><br><span class="line">    system(<span class="string">"ip link add veth0 type veth peer name veth1"</span>);</span><br><span class="line">    system(cmd);</span><br><span class="line">    system(<span class="string">"ip link set veth0 up"</span>);</span><br><span class="line">    system(<span class="string">"ip addr add 192.168.55.1/24 dev veth0"</span>);</span><br><span class="line">    <span class="built_in">free</span>(cmd);</span><br><span class="line">    set_id_map((<span class="keyword">long</span>)child_pid, <span class="number">0</span>, (<span class="keyword">long</span>)geteuid(), <span class="number">1</span>, <span class="string">"uid_map"</span>);</span><br><span class="line">    set_id_map((<span class="keyword">long</span>)child_pid, <span class="number">0</span>, (<span class="keyword">long</span>)getegid(), <span class="number">1</span>, <span class="string">"gid_map"</span>);</span><br><span class="line">    close(checkpoint[<span class="number">1</span>]);</span><br><span class="line">    waitpid(child_pid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    mount(<span class="string">"proc"</span>, <span class="string">"/proc"</span>, <span class="string">"proc"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过在父进程中修改映射可以看到子进程前后两次获得的uid和gid均不同，其实根据刚才讲到的规则子进程也可以将自己的映射的修改掉，只需要对此代码稍作改动即可有兴趣可以自行测试，需要注意的一点是这里因为加上了其他标记所以必须使用root运行那么子进程修改的时候不能设置outside为1000，会提示<code>RTNETLINK answers: Operation not permitted</code>，因为这时候使用的root用户其用户组为0，关于此节内容想深入理解还可以看看这个<a href="http://www.seteuid0.com/cve-2013-1959%E5%86%85%E6%A0%B8%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%88%A9%E7%94%A8%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/" target="_blank" rel="external">bug分析</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要是&lt;a href=&quot;http://yuedu.baidu.com/ebook/d817967416fc700abb68fca1?fr=aladdin&amp;amp;key=docker%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98&quot;&gt;Docker入门实战&lt;/a&gt;这本电子书的学习记录，对其中一些原理相关代码的记录和实践就不再赘述一些更为基本的概念，这本书是由&lt;a href=&quot;http://www.dockone.io&quot;&gt;DockerOne&lt;/a&gt;编译的，其条理和内容都很不错非常值得一读。继续阅读之前需要先了解下容器是什么、和VM的区别是什么、Docker解决了什么问题以及镜像、数据卷、LXC、Cgroups、Union文件系统等基本概念，然后安装好docker和gcc就可以愉快的进入下文了，如果对Docker的源码有兴趣可以看看这个系列的文章&lt;a href=&quot;http://www.infoq.com/cn/search.action?queryString=Docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90&amp;amp;page=1&amp;amp;searchOrder=&amp;amp;sst=uZnwt8z7LUYMOcuH&quot;&gt;列表&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="http://www.suwey.net/categories/docker/"/>
    
    
      <category term="docker" scheme="http://www.suwey.net/tags/docker/"/>
    
      <category term="Linux" scheme="http://www.suwey.net/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Jquery插件Table of Contents修改</title>
    <link href="http://www.suwey.net/2017/03/15/jquery-toc-bug-fix/"/>
    <id>http://www.suwey.net/2017/03/15/jquery-toc-bug-fix/</id>
    <published>2017-03-15T04:00:00.000Z</published>
    <updated>2017-03-30T17:25:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>装完博客之后发现其他主题的文章有个新功能：可以在正文右边生成文章的目录，也就是TOC（table of contents)。 于是想把这个功能移植过来，但是不太清楚hexo生成文章的过程，也不想和其他主题一样都固定在文章右边，这样在浏览文章后面时无法方便的切换到其他段落，所以就想能否直接用js抓取正文的标题自动生成一个TOC列表，搜索后发现有个jquery的插件<a href="http://projects.jga.me/toc/" target="_blank" rel="external">toc</a>正好有这个功能，然后问题就来了。</p>
<a id="more"></a>
<h2 id="无法真正的smoothScroll"><a href="#无法真正的smoothScroll" class="headerlink" title="无法真正的smoothScroll"></a>无法真正的smoothScroll</h2><p>装上使用后发现一直不对，具体可以参考bootstrap的关于页面<a href="http://www.bootcss.com/about/" target="_blank" rel="external">bootstrap</a>。很明显点击左侧的时候无法真的顺滑滚动（可对比本页面效果），都是直接跳到标题处而且因为有个顶端的nav，标题还会被遮挡（这个不同浏览器表现还不太一样，IE有时候只会遮挡一部分）。这个问题排查了很久，一直到发现无论如何设置参数效果都是这样，遂决定看看源码。</p>
<h2 id="排查toc-js源码"><a href="#排查toc-js源码" class="headerlink" title="排查toc.js源码"></a>排查toc.js源码</h2><p>使用的时候是安装官网demo的设置设定的，所以要排查问题，先从设置开始看看整个执行的流程。</p>
<h3 id="排查执行流程"><a href="#排查执行流程" class="headerlink" title="排查执行流程"></a>排查执行流程</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#toc'</span>).toc(&#123;</span><br><span class="line">    <span class="string">'selectors'</span>: <span class="string">'h1,h2,h3'</span>, <span class="comment">//elements to use as headings</span></span><br><span class="line">    <span class="string">'container'</span>: <span class="string">'body'</span>, <span class="comment">//element to find all selectors in</span></span><br><span class="line">    <span class="string">'smoothScrolling'</span>: <span class="literal">true</span>, <span class="comment">//enable or disable smooth scrolling on click</span></span><br><span class="line">    <span class="string">'prefix'</span>: <span class="string">'toc'</span>, <span class="comment">//prefix for anchor tags and class names</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>设置的时候smoothScrolling的值为true,然后看初始化代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$.fn.toc = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> opts = $.extend(&#123;&#125;, jQuery.fn.toc.defaults, options);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> container = $(opts.container);</span><br><span class="line">  <span class="keyword">var</span> headings = $(opts.selectors, container);</span><br><span class="line">  <span class="keyword">var</span> headingOffsets = [];</span><br><span class="line">  <span class="keyword">var</span> activeClassName = opts.activeClass;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> scrollTo = <span class="function"><span class="keyword">function</span>(<span class="params">e, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (opts.smoothScrolling &amp;&amp; <span class="keyword">typeof</span> opts.smoothScrolling === <span class="string">'function'</span>) &#123;</span><br><span class="line">      e.preventDefault();</span><br><span class="line">      <span class="keyword">var</span> elScrollTo = $(e.target).attr(<span class="string">'href'</span>);</span><br><span class="line"></span><br><span class="line">      opts.smoothScrolling(elScrollTo, opts, callback);</span><br><span class="line">    &#125;</span><br><span class="line">    $(<span class="string">'li'</span>, self).removeClass(activeClassName);</span><br><span class="line">    $(e.target).parent().addClass(activeClassName);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>这段代码就是$().toc({})后做的事情了，可以看到初始化的设置被当作options传入，然后对toc.defaults的设置进行了覆盖作为opts变量继续传递。重点看scrollTo方法：if语句先判断opts.smoothScrolling为true然后在判断其类型是function然后才真的进行smoothScrolling，所以问题就在这了，即使在脚本语言里应该也没法让一个变量同时是boolean型又是function吧。这个bug导致scrollTo方法根本起不到预想的作用。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>根据上面的分析，只需要把scrollTo方法里面if语句前面的<code>opt.smoothScrolling</code>改成<code>opt.smoothScroll</code>然后在使用toc方法设置的时候把<code>&#39;smoothScrolling&#39;: true</code>改成<code>&#39;smoothScroll&#39;: true</code>就行了。</p>
<h3 id="避免nav遮挡"><a href="#避免nav遮挡" class="headerlink" title="避免nav遮挡"></a>避免nav遮挡</h3><p>有些网站会和本站一样有个顶端固定的nav，仅仅按照上面的设置会在跳转的时候造成遮挡损失一部分标题内容，看文档应该设置一个参数<code>scrollToOffset</code>，但是这个参数应该设置为多少呢，猜想应该是nav的高度，所以很自然的设置为<code>$(&#39;nav&#39;).outerHeight()</code>。貌似问题解决了，但是既然已经分析到这了顺便看看这个参数如何起效的吧。</p>
<h2 id="分析smoothScroll"><a href="#分析smoothScroll" class="headerlink" title="分析smoothScroll"></a>分析smoothScroll</h2><p>接着上文的scrollTo方法进入可以看到使用了opts.smoothScrolling方法，根据前面的分析opts的值来自初始化的选项覆盖默认选项后的结果，所以看看默认的方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">smoothScrolling: <span class="function"><span class="keyword">function</span>(<span class="params">target, options, callback</span>) </span>&#123;</span><br><span class="line">    $(target).smoothScroller(&#123;</span><br><span class="line">      <span class="attr">offset</span>: options.scrollToOffset</span><br><span class="line">    &#125;).on(<span class="string">'smoothScrollerComplete'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      callback();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>其中target就是生成的toc中a标签地址href的值，options就是opts，callback的真相得看看下面这段。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/build TOC item</span><br><span class="line">      <span class="keyword">var</span> a = $(<span class="string">'&lt;a/&gt;'</span>)</span><br><span class="line">        .text(opts.headerText(i, heading, $h))</span><br><span class="line">        .attr(<span class="string">'href'</span>, <span class="string">'#'</span> + anchorName)</span><br><span class="line">        .bind(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">          $(<span class="built_in">window</span>).unbind(<span class="string">'scroll'</span>, highlightOnScroll);</span><br><span class="line">          scrollTo(e, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            $(<span class="built_in">window</span>).bind(<span class="string">'scroll'</span>, highlightOnScroll);</span><br><span class="line">          &#125;);</span><br><span class="line">          el.trigger(<span class="string">'selected'</span>, $(<span class="keyword">this</span>).attr(<span class="string">'href'</span>));</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="toc原理"><a href="#toc原理" class="headerlink" title="toc原理"></a>toc原理</h3><p>插件的原理是将container容器里面的selector选择器选中的元素（也就是标题）前面生成一个span标签，id为前缀加序号（例如toc0,toc1）。然后生成一个ul列表，列表项为href指向span标签id的地址（例如#toc0,#toc1）。这样其实如果不使用smoothScroll可以直接点击跳转了，但是对本博客这种页面顶端有nav的就会导致标题被遮挡的情况。（所以因为有上文分析的bug存在，是一直都是这样的浏览器默认行为的）</p>
<p>根据这段代码可以得知scrollTo传给smoothScrolling的callback函数就是<code>highlightOnScroll</code>。因为scrollTo的判断bug存在，修改之前highlightOnScroll的效果在点击跳转后会失效的，因为在unbind之后没有机会再bind回来了，所以我一度直接把unbind的函数删了。</p>
<h3 id="smoothScroller"><a href="#smoothScroller" class="headerlink" title="smoothScroller"></a>smoothScroller</h3><p>回到smoothScrolling方法可以看到：讲生成的ul列表链接的href指向元素上生成了一个smoothScroller对象，传入了一个参数就是初始化设置的<code>scrollToOffset</code>。所以看看smoothScroller的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.fn.smoothScroller = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    options = $.extend(&#123;&#125;, $.fn.smoothScroller.defaults, options);</span><br><span class="line">    <span class="keyword">var</span> el = $(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    $(options.scrollEl).animate(&#123;</span><br><span class="line">      <span class="attr">scrollTop</span>: el.offset().top - $(options.scrollEl).offset().top - options.offset</span><br><span class="line">    &#125;, options.speed, options.ease, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>拿到options后也是对默认值进行了一次覆盖，可以看到默认的<code>options.scrollEl</code>的值为<code>&#39;body,html&#39;</code>，现在可以清楚看到smoothScroll的执行过程了：在ul列表链接href指向的元素上向上移动一段距离，距离的大小为该元素的到top的距离减去body到top的距离再减去自定义的offset值。</p>
<p>综上所述，smoothScroll就是把生成在选中标题前面span标签向上移动该标签到页面顶端的距离减去offset的距离，也就是初始化设置中的scrollToOffset的值。所以前面设置为nav的高度就对了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;装完博客之后发现其他主题的文章有个新功能：可以在正文右边生成文章的目录，也就是TOC（table of contents)。 于是想把这个功能移植过来，但是不太清楚hexo生成文章的过程，也不想和其他主题一样都固定在文章右边，这样在浏览文章后面时无法方便的切换到其他段落，所以就想能否直接用js抓取正文的标题自动生成一个TOC列表，搜索后发现有个jquery的插件&lt;a href=&quot;http://projects.jga.me/toc/&quot;&gt;toc&lt;/a&gt;正好有这个功能，然后问题就来了。&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://www.suwey.net/categories/js/"/>
    
    
      <category term="toc" scheme="http://www.suwey.net/tags/toc/"/>
    
  </entry>
  
  <entry>
    <title>在hexo中写时序图和UML流程图</title>
    <link href="http://www.suwey.net/2016/03/27/hexo-sequece-flow-chart/"/>
    <id>http://www.suwey.net/2016/03/27/hexo-sequece-flow-chart/</id>
    <published>2016-03-27T02:57:15.000Z</published>
    <updated>2017-03-14T17:17:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>偶然的机会发现CSDN博客有markdown编辑器，点开一看发现支持用markdown写时序图和流程图感到非常给力，于是想将其用在hexo博客中，搜了一下发现很遗憾没有类似的插件就只能自己动手丰衣足食了。其实在最开始玩hexo的时候基于<a href="http://www.jointjs.com" target="_blank" rel="external">jointjs</a>把类图搞了一张到博客玩了下，那时候因为没有对应语法所以每次要把代码在html里面写好然后copy到博客文章里，显然玩了几次后面谁也不想玩了，这次CSDN编辑器里面就提供了比较简单的语法然后根据语法生成图形这样易用性就非常好了。打开编辑器直接拖到页面下方就可以看到编辑器使用的开源项目，貌似整个编辑器都是学的<a href="https://stackedit.io/editor" target="_blank" rel="external">stackedit</a>，关于两种图的项目分别是<a href="https://github.com/bramp/js-sequence-diagrams" target="_blank" rel="external">js-sequence-diagrams</a>和<a href="https://github.com/adrai/flowchart.js" target="_blank" rel="external">flowchart.js</a>，那么就看能不能在hexo中用上了。</p>
<a id="more"></a>
<h2 id="尝试写成插件"><a href="#尝试写成插件" class="headerlink" title="尝试写成插件"></a>尝试写成插件</h2><p>最开始是想学着官方写个插件，既然官方可以解决highlight语法高亮的问题那么可以仿照解决这个问题，只需要解析对应的语法为某个div然后引用上面两个项目初始化渲染就可以了。于是就稍微研究了下hexo的原理，找到了<a href="https://github.com/hexojs/hexo-renderer-marked" target="_blank" rel="external">hexo-renderer-marked</a>是解决highlight的地方，刚小小的兴奋了一下发现里面是调用<a href="https://github.com/chjj/marked" target="_blank" rel="external">marked</a>实现的，这就不好搞了，以我的功底直接去改这种项目还是很虚的，更别说在尝试过程中还遇到一些头疼的问题：</p>
<ol>
<li>npm经常卡住，这个好解决直接换成cnpm就好多了</li>
<li>js-sequence-diagrams这个项目没发布到npm，于是我自己fork了一个</li>
<li>既然自己fork的那就直接用git安装吧，又发现虽然<code>npm install -h</code>明明说支持<code>git://</code>但是我死活也装不上，只能改成<code>git+https://git@github.com...</code>才行</li>
<li>终于可以下载了结果发现js-sequence-diagrams项目的package.json没有写version无法安装，于是自己加上version</li>
<li>以为天下太平了结果发现flowchart.js项目依赖的<a href="http://raphaeljs.com/" target="_blank" rel="external">rapheal</a>写法是<code>git://</code>，改之，结果发现后者依赖一个叫<code>eve</code>的项目写的也是<code>git://</code>，果断fork了后者再改之</li>
<li>本来以为到此已经可以见到太阳了，但是当我照着搜索来的nodejs module写法写完第一句require然后运行的时候看到了…</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/home/suwey/hexo-renderer-chart/node_modules/.npminstall/raphael/2.1.4/raphael/dev/raphael.core.js:96</span><br><span class="line">            doc: document,</span><br><span class="line">                 ^</span><br><span class="line"></span><br><span class="line">ReferenceError: document is not defined</span><br><span class="line">    at /home/suwey/hexo-renderer-chart/node_modules/.npminstall/raphael/2.1.4/raphael/dev/raphael.core.js:96:18</span><br><span class="line">    at /home/suwey/hexo-renderer-chart/node_modules/.npminstall/raphael/2.1.4/raphael/dev/raphael.core.js:15:26</span><br><span class="line">    at Object.&lt;anonymous&gt; (/home/suwey/hexo-renderer-chart/node_modules/.npminstall/raphael/2.1.4/raphael/dev/raphael.core.js:19:2)</span><br></pre></td></tr></table></figure>
<p>然后我只能放弃了，继续研究可能对于nodejs大牛们来说不是事但是对于边搜索边做的我来说已经耗费了太大的精力了，毕竟对于我来说只是想好好写博客而已。那么就这样放弃这么好的功能吗？可能愿意用hexo写博客的99%都是技术相关的，流程图这类可能还真的需要用，如果先在软件里面画然后截图效果有时候不是很好，放上来会很模糊，而且相比之下IDE就可以自动生成的类图可能还真没有时序图和流程图需要画的多，那么再换个思路试试吧。</p>
<h2 id="不转换只拼接"><a href="#不转换只拼接" class="headerlink" title="不转换只拼接"></a>不转换只拼接</h2><p>前面插件写法的思路是想直接把源文件的内容转换成图形代码生成到最终的html里面去，既然这样不可行（至少对于我来说），那么可不可以只是在生成文件后将对应语法的段落转换为带有特定标识的<code>&lt;div&gt;</code>然后在文件末尾添加上初始化的代码就好了呢？先复制一段时序图的示例看看会生成怎样的结果：</p>
<p><img src="/attachments/img/seq-syntax.jpg" alt="seq-syntax"></p>
<p>观察到默认是会生成为<code>highlight plain</code>的格式（这里我放了一个截图的原因是如果把这段直接写出来现在就会生成为时序图，如果外层再包一个<code>highlight plain</code>的语法的话hexo解析嵌套的语法会导致显示错误），那么证明和highlight处理有关，查阅代码发现是引用了<a href="https://github.com/hexojs/hexo-util" target="_blank" rel="external">hexo-util</a>的代码，阅读代码发现是在<code>function highlight(str, options)</code>中进行了判断，其会自动推测highlight的语言类型如果无法判断则默认为plain格式，显然这里的sequence是无法识别的，那么只需要修改hexo-util中的hightlight.js文件即可解决将对应语法的段落转化为特定标识的<code>&lt;div&gt;</code>的问题。</p>
<h2 id="修改hexo-util"><a href="#修改hexo-util" class="headerlink" title="修改hexo-util"></a>修改hexo-util</h2><p>因为语法和hexo中highlight的语法完全一样，所以修改hexo-util项目lib目录下的highlight.js文件，修改后完整文件在<a href="/attachments/hexo-util/highlight.js">hexo-util/lib/highlight.js</a>，首先修改<code>function highlight(str, options)</code>如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = &#123;</span><br><span class="line">    <span class="attr">value</span>: encodePlainString(str),</span><br><span class="line">    <span class="attr">language</span>: lang.toLowerCase()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">result.isChart = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (result.language === <span class="string">'sequence'</span> || result.language === <span class="string">'flow'</span>) &#123;</span><br><span class="line">    result.isChart = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result.language === <span class="string">'plain'</span> || result.isChart) &#123;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在遇到<code>sequence</code>或者<code>flow</code>的时候就不会解析为<code>plain</code>格式了，这里给结果增加了一个<code>isChart</code>属性，且如果为真直接返回不再进行语言判断，其返回后在<code>function highlightUtil(str, options)</code>中处理，需要修改此函数使其不再按照highlight格式生成html，具体如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> caption = options.caption;</span><br><span class="line"><span class="keyword">var</span> tab = options.tab;</span><br><span class="line"><span class="keyword">var</span> data = highlight(str, options);</span><br><span class="line"><span class="keyword">if</span> (data.isChart) &#123;</span><br><span class="line">    <span class="keyword">return</span> charResult(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!wrap) <span class="keyword">return</span> data.value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lines = data.value.split(<span class="string">'\n'</span>);</span><br></pre></td></tr></table></figure>
<p>这里发现是图表数据则直接交给<code>charResult</code>函数处理，此函数实现很简单：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">charResult</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">'&lt;div class="'</span> + data.language  + <span class="string">'"&gt;'</span>;</span><br><span class="line">  result += data.value;</span><br><span class="line">  result += <span class="string">'&lt;/div&gt;'</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此就完成了将图表语法处理成带有class标签的div工作，那么后面就是将html中的div变成图表了。</p>
<h2 id="修改主题完成图表渲染"><a href="#修改主题完成图表渲染" class="headerlink" title="修改主题完成图表渲染"></a>修改主题完成图表渲染</h2><p>这一步就比较简单了，通常是找到主题的模板文件进行修改，一般修改页面底部即可，这里我是在本主题的<code>/layout/_partial/after-footer.ejs</code>中添加了这样一段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.chart)&#123; %&gt;</span><br><span class="line">&lt;%- js(&apos;js/raphael&apos;) %&gt;</span><br><span class="line">&lt;%- js(&apos;js/underscore&apos;) %&gt;</span><br><span class="line">&lt;%- js(&apos;js/sequence-diagram&apos;) %&gt;</span><br><span class="line">&lt;%- js(&apos;js/flowchart&apos;) %&gt;</span><br><span class="line">&lt;%- partial(&apos;chart&apos;) %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
<p>判断主题是否需要开启图表功能，这里需要在主题的<code>_config.yml</code>里加一个开关：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Support sequence &amp; flow chart</span><br><span class="line">chart: true</span><br></pre></td></tr></table></figure>
<p>别忘了在主题<code>source/js</code>目录下添加<code>raphael</code>等js文件，然后在<code>/layout/_partial</code>目录下新建一个<code>chart.ejs</code>文件，里面放上处理图表的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.chart)&#123; %&gt;</span><br><span class="line">&lt;!-- Chart Render --&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  $(&quot;.sequence&quot;).sequenceDiagram(&#123;theme: &apos;simple&apos;&#125;);</span><br><span class="line">  var flowCount = 0;</span><br><span class="line">  $(&quot;.flow&quot;).each(function() &#123;</span><br><span class="line">      var el = $(this);</span><br><span class="line">      el.hide();</span><br><span class="line">      el.after(&apos;&lt;div id=&quot;flow-&apos; + flowCount + &apos;&quot;&gt;&lt;/div&gt;&apos;);</span><br><span class="line">      var chart = flowchart.parse(el.text());</span><br><span class="line">      chart.drawSVG(&apos;flow-&apos; + flowCount);</span><br><span class="line">      flowCount++;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;!-- End Chart Render --&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
<p>这里对<code>sequence</code>的处理比较简单，因为支持直接在语句元素上画图所以只需要一句初始化语句就可以了，但是<code>flow</code>这种因为默认不支持直接在元素上画图表，而且还需要另外一个单独的<code>&lt;div&gt;</code>作为图表的容器，如果不指定或者试图使用写着语句的div上画图则会导致图表位置不可控，因此需要自己遍历所有图表依次隐藏语句div并添加一个唯一id的容器div然后初始化。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，通过对hexo-util和主题文件的修改联合完成了将图表语法生成为html和将html渲染成图表的两个步骤，可以在hexo中愉快的使用时序图和UML流程图了。在测试过程中发现本主题引用的<code>require.js</code>和<code>raphael.js</code>等图表使用的js会产生冲突，提示为<code>Mismatch anonymous define module</code>，本来试图在搜索的指引下解决此问题结果发现将<code>raphael</code>等几个js文件改得一塌糊涂后依然是云里雾里，为了免得图表组件更新后又稀里糊涂的乱改一气最后只得将本主题几个使用了require的js文件全部修改为了原生的写法。所以本次虽然最终达到了目的但是无论是对hexo的修改还是对图表js等的引用可能都不是最优方案，这里就当作是抛砖引玉了希望以后可以看到更好的解决方式，最后既然说了这么多当然得放上几个图检验下工作成果，那就都放在末尾了。</p>
<h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><div class="sequence">Alice-&gt;Bob: Hello Bob, how are you?
Note right of Bob: Bob thinks
Bob--&gt;Alice: 我很好 thanks!</div>
<h3 id="流程图1"><a href="#流程图1" class="headerlink" title="流程图1"></a>流程图1</h3><div class="flow">st=&gt;start: Start|past:&gt;http://www.google.com[blank]
e=&gt;end: End:&gt;http://www.google.com
op1=&gt;operation: My Operation|past
op2=&gt;operation: Stuff|current
sub1=&gt;subroutine: My Subroutine|invalid
cond=&gt;condition: Yes
or No?|approved:&gt;http://www.google.com
c2=&gt;condition: Good idea|rejected
io=&gt;inputoutput: catch something中文|request

st-&gt;op1(right)-&gt;cond
cond(yes, right)-&gt;c2
cond(no)-&gt;sub1(left)-&gt;op1
c2(yes)-&gt;io-&gt;e
c2(no)-&gt;op2-&gt;e</div>
<h3 id="流程图2"><a href="#流程图2" class="headerlink" title="流程图2"></a>流程图2</h3><div class="flow">st=&gt;start: Start
e=&gt;end
op=&gt;operation: My Operation
cond=&gt;condition: Yes or No?

st-&gt;op-&gt;cond
cond(yes)-&gt;e
cond(no)-&gt;op</div>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;偶然的机会发现CSDN博客有markdown编辑器，点开一看发现支持用markdown写时序图和流程图感到非常给力，于是想将其用在hexo博客中，搜了一下发现很遗憾没有类似的插件就只能自己动手丰衣足食了。其实在最开始玩hexo的时候基于&lt;a href=&quot;http://www.jointjs.com&quot;&gt;jointjs&lt;/a&gt;把类图搞了一张到博客玩了下，那时候因为没有对应语法所以每次要把代码在html里面写好然后copy到博客文章里，显然玩了几次后面谁也不想玩了，这次CSDN编辑器里面就提供了比较简单的语法然后根据语法生成图形这样易用性就非常好了。打开编辑器直接拖到页面下方就可以看到编辑器使用的开源项目，貌似整个编辑器都是学的&lt;a href=&quot;https://stackedit.io/editor&quot;&gt;stackedit&lt;/a&gt;，关于两种图的项目分别是&lt;a href=&quot;https://github.com/bramp/js-sequence-diagrams&quot;&gt;js-sequence-diagrams&lt;/a&gt;和&lt;a href=&quot;https://github.com/adrai/flowchart.js&quot;&gt;flowchart.js&lt;/a&gt;，那么就看能不能在hexo中用上了。&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://www.suwey.net/categories/hexo/"/>
    
    
      <category term="js-sequece-diagrams" scheme="http://www.suwey.net/tags/js-sequece-diagrams/"/>
    
      <category term="flowchart.js" scheme="http://www.suwey.net/tags/flowchart-js/"/>
    
  </entry>
  
</feed>
